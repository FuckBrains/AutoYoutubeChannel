{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 5,
   "metadata": {},
   "outputs": [],
   "source": [
    "import random\n",
    "import time\n",
    "from http import client\n",
    "import httplib2\n",
    "\n",
    "from googleapiclient.discovery import build\n",
    "from googleapiclient.errors import HttpError\n",
    "from googleapiclient.http import MediaFileUpload"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "metadata": {},
   "outputs": [],
   "source": [
    "httplib2.RETRIES = 1\n",
    "\n",
    "# Maximum number of times to retry before giving up.\n",
    "MAX_RETRIES = 10\n",
    "\n",
    "# Always retry when these exceptions are raised.\n",
    "RETRIABLE_EXCEPTIONS = (httplib2.HttpLib2Error, IOError, client.NotConnected,\n",
    "    client.IncompleteRead, client.ImproperConnectionState,\n",
    "    client.CannotSendRequest, client.CannotSendHeader,\n",
    "    client.ResponseNotReady, client.BadStatusLine)\n",
    "\n",
    "# Always retry when an apiclient.errors.HttpError with one of these status\n",
    "# codes is raised.\n",
    "RETRIABLE_STATUS_CODES = [500, 502, 503, 504]\n",
    "\n",
    "VALID_PRIVACY_STATUSES = ('public', 'private', 'unlisted')\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "def upload_video(\n",
    "        credentials,\n",
    "        file,\n",
    "        title='video title',\n",
    "        description='video sescription',\n",
    "        category=22,\n",
    "        privacy='private',\n",
    "        tags=[]\n",
    "    ):\n",
    "    \"\"\"\n",
    "    youtube is made with get_authenticated_service()\n",
    "    category is a number, see https://developers.google.com/youtube/v3/docs/videoCategories/list for more\n",
    "    raises HttpError if connection error\n",
    "    \"\"\"\n",
    "    youtube_service = build('youtube', 'v3', credentials=credentials)\n",
    "\n",
    "    body=dict(\n",
    "        snippet=dict(\n",
    "            title=title,\n",
    "            description=description,\n",
    "            tags=tags,\n",
    "            categoryId=category\n",
    "        ),\n",
    "        status=dict(\n",
    "            privacyStatus=privacy\n",
    "        )\n",
    "    )\n",
    "\n",
    "    # Call the API's videos.insert method to create and upload the video.\n",
    "    insert_request = youtube_service.videos().insert(\n",
    "        part=','.join(body.keys()),\n",
    "        body=body,\n",
    "        # The chunksize parameter specifies the size of each chunk of data, in\n",
    "        # bytes, that will be uploaded at a time. Set a higher value for\n",
    "        # reliable connections as fewer chunks lead to faster uploads. Set a lower\n",
    "        # value for better recovery on less reliable connections.\n",
    "        #\n",
    "        # Setting 'chunksize' equal to -1 in the code below means that the entire\n",
    "        # file will be uploaded in a single HTTP request. (If the upload fails,\n",
    "        # it will still be retried where it left off.) This is usually a best\n",
    "        # practice, but if you're using Python older than 2.6 or if you're\n",
    "        # running on App Engine, you should set the chunksize to something like\n",
    "        # 1024 * 1024 (1 megabyte).\n",
    "        media_body=MediaFileUpload(file, chunksize=-1, resumable=True)\n",
    "    )\n",
    "\n",
    "    return resumable_upload(insert_request)\n",
    "\n",
    "# This method implements an exponential backoff strategy to resume a\n",
    "# failed upload.\n",
    "def resumable_upload(request):\n",
    "    response = None\n",
    "    error = None\n",
    "    retry = 0\n",
    "    while response is None:\n",
    "        try:\n",
    "            print()\n",
    "            print( 'Uploading file...')\n",
    "            status, response = request.next_chunk()\n",
    "            if response is not None:\n",
    "                # print(response)\n",
    "                if 'id' in response:\n",
    "                    print()\n",
    "                    print( 'Video id \"%s\" was successfully uploaded.' % response['id'])\n",
    "                    return f'https://www.youtube.com/watch?v={response[\"id\"]}'\n",
    "                else:\n",
    "                    exit('The upload failed with an unexpected response: %s' % response)\n",
    "        except HttpError as e:\n",
    "            if e.resp.status in RETRIABLE_STATUS_CODES:\n",
    "                error = 'A retriable HTTP error %d occurred:\\n%s' % (e.resp.status, e.content)\n",
    "            else:\n",
    "                raise\n",
    "        except RETRIABLE_EXCEPTIONS as e:\n",
    "            error = 'A retriable error occurred: %s' % e\n",
    "\n",
    "        if error is not None:\n",
    "            print( error)\n",
    "            retry += 1\n",
    "            if retry > MAX_RETRIES:\n",
    "                exit('No longer attempting to retry.')\n",
    "\n",
    "            max_sleep = 2 ** retry\n",
    "            sleep_seconds = random.random() * max_sleep\n",
    "            print( 'Sleeping %f seconds and then retrying...' % sleep_seconds)\n",
    "            time.sleep(sleep_seconds)"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.7.3"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 2
}
